API documentation
-----------------

- doc for cache

- doc for mbox

- doc for MH

- doc for NNTP

- doc for POP3

- comments within code


mail drivers
------------

- bodystructure should be cached

- sort messages

- SMTP - recipient resolver


IMF
---

- rewrite efficient RFC 2822 message parser


IMAP
----

- rewrite efficient IMAP parser


MIME
----

- generate MIME-encoded headers (done in etpan)


binding
-------

- perl binding

- objective C binding

- C++ mapping

- python binding

- emacs-lisp binding

- ocaml binding


miscellaneous
-------------

- SASL authentification : cyrus-sasl
	CRAM-MD5 / DIGEST-MD5

- S/MIME / GPG /PGP

- filtering / scoring / searching language

- generic tools for mail clients

- check SSL certificates


compilation
-----------

- improve autoconf / portability (header checks...)



new API
-------

wim delvaux


-- storage

struct storage {
  void * data; /* storage dependant */
}

storage_bind(&storage, driver);
storage_release(&storage);

storage_commit(storage)

storage_get_folder_set(storage, pattern, &set) -> list of subfolders
 list of pair (basename, path)
storage_get_folder_tree(storage, pattern, &tree) -> tree of folders
 tree of pair (basename, path)
folder_list_cleanup(&list)
folder_tree_cleanup(&list)

storage_set_option(storage, option_id, value, ...)
storage_set_option_by_name(storage, option_name, value, ...)

storage_build_folder_name(storage, name, ...)
storage_create_folder(storage, name);
storage_delete_folder(storage, name);
storage_rename_folder(storage, folder, newname);

struct etpan_folder {
  struct storage * storage;
}

one connection per storage,
a connection can be a set of TCP/IP socket

-- folder

folder_bind(&folder, storage, path);
folder_release(&folder);

folder_set_option(folder, option_id, value, ...)
folder_set_option_by_name(folder, option_name, value, ...)
folder_ctl(folder, function_id, param, ...)
folder_ctl_by_name(folder, function_name, param, ...)

folder_get_path(folder)

when an action is done on folder we have to query the storage state,
to see which folder we are manipulating and select the right folder.

one binding per folder.

several binding may be using one shared TCP/IP connection
or one TCP/IP connection for each binding.

folder_commit(folder) -- write all flags the data down for persistant
folder_expunge(folder) -- delete messages marked as deleted
folder_status(folder, &count, &unread_count, &new_count) 
     -- return messages number, unread messages number, new messages number
folder_append_message(folder, message) -- add a message
   (message will already contain the new flags),
   really add it after commit()

folder_get_envelopes_list(folder, &list) -- return list of message
        binded to folder.
folder_fill_envelopes_list(folder, &list) -- fill the envelope info of the
        list of messages.

switch_connection_to_binding()

struct connection {
  struct current_binding * binding;
}


struct etpan_message {
  struct etpan_folder * folder;
}

message_bind(&message, folder, msg_id) -- initializes the message structure
message_release(&message) -- release the message
message_commit(&message) -- let the folder structure knows the flags we changed
message_get_mime_tree(&message, &mime_tree) -- return the MIME structure of
  the message
message_mime_tree_cleanup(mime_tree) -- free the mime structure returned

message_get_flags(&message, &flags) -- fetch the flags of the message
message_flags_cleanup(&message, flags) -- free the flags

struct etpan_mime {
  struct etpan_message * message;
}

message_get_parsed_header(msg, &header)
message_get_raw_header(msg, &header)
message_get_header_set(msg, &headers)
message_get_body(msg, &Body)

standard headers
special headers
body
flags
