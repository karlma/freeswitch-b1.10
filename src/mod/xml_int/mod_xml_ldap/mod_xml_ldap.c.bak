/* 
 * FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application
 * Copyright (C) 2005/2006, Anthony Minessale II <anthmct@yahoo.com>
 *
 * Version: MPL 1.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application
 *
 * The Initial Developer of the Original Code is
 * Anthony Minessale II <anthmct@yahoo.com>
 * Portions created by the Initial Developer are Copyright (C)
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 * 
 * Anthony Minessale II <anthmct@yahoo.com> 
 * Bret McDanel <trixter AT 0xdecafbad.com>
 * Justin Cassidy <xachenant@hotmail.com>
 * John Skopis <john+fs@skopis.com>
 *
 * mod_xml_ldap.c -- LDAP XML Gateway
 *
 */
#include <switch.h>
#include <stdlib.h>
#include <string.h>
#ifdef MSLDAP
#include <windows.h>
#include <winldap.h>
#include <winber.h>
#define LDAP_OPT_SUCCESS LDAP_SUCCESS
#else
#include <lber.h>
#include <ldap.h>
#endif

#define LDAP_CONFIG 0
#define LDAP_DIRECTORY 1

SWITCH_MODULE_LOAD_FUNCTION(mod_xml_ldap_load);
SWITCH_MODULE_SHUTDOWN_FUNCTION(mod_xml_ldap_shutdown);
SWITCH_MODULE_DEFINITION(mod_xml_ldap, mod_xml_ldap_load, mod_xml_ldap_shutdown, NULL);

struct xml_binding {
  char *bindings;
	char *ldap_base;
  char *binddn;
  char *bindpass;
};


typedef struct xml_binding xml_binding_t;

struct ldap_c {
  LDAP *ld;
  LDAPMessage *msg;
  LDAPMessage *entry;
  BerElement *berkey;
  BerElement *berval;
  char *key;
  char *val;
  char **keyvals;
  char **valvals;

};

#define XML_LDAP_SYNTAX "[debug_on|debug_off]"
SWITCH_STANDARD_API(xml_ldap_function)
{
	if (session) {
		return SWITCH_STATUS_FALSE;
	}

	if (switch_strlen_zero(cmd)) {
		goto usage;
	}

	if (!strcasecmp(cmd, "debug_on")) {
	} else if (!strcasecmp(cmd, "debug_off")) {
	} else {
		goto usage;
	}

	stream->write_function(stream, "OK\n");
	return SWITCH_STATUS_SUCCESS;

usage:
	stream->write_function(stream, "USAGE: %s\n", XML_LDAP_SYNTAX);
	return SWITCH_STATUS_SUCCESS;
}


static switch_status_t xml_ldap_result( void *ldap_connection, char *xml, int bind)
{
	struct ldap_c *ldap = ldap_connection;
  char *tiny_xml = NULL;
  char *bigger_xml = NULL;
  char *temp_xml = NULL;
  char *super_xml = NULL;;
  int i = 0, len = 0;

  xml = NULL;



  for (ldap->entry = ldap_first_entry(ldap->ld,ldap->msg); ldap->entry != NULL; ldap->entry = ldap_next_entry(ldap->ld,ldap->entry)) {
    ldap->key = ldap_first_attribute( ldap->ld, ldap->entry, &ldap->berkey );
    ldap->val = ldap_first_attribute( ldap->ld, ldap->entry, &ldap->berval );
    switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "got key %s val %s\n", ldap->key, ldap->val);
    do {
      if(!strstr(ldap->val, ldap->key) && strstr(ldap->val,"value") ) {
          switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, " val %s doesn't match key %s and have name\n",ldap->val,ldap->key);
          do { 
            ldap->val = ldap_next_attribute(ldap->ld, ldap->entry, ldap->berval );
            switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "looping on next attr %s\n",ldap->val);
          } while ( ldap->val != NULL && !strstr(ldap->val,ldap->key) && strstr(ldap->val,"value") );
          switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "reached the end of the loop proceeding\n");
        //} else {
          switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "we are matched up on %s %s",ldap->key,ldap->val);
          // guess we found our matching pair param+paramval variable+variablevalue etc
          if ( 
              ( (ldap->keyvals = ldap_get_values( ldap->ld, ldap->entry, ldap->key )) != NULL )
              &&
              ( (ldap->valvals = ldap_get_values( ldap->ld, ldap->entry, ldap->val )) != NULL ) )  {
            if ( ldap_count_values ( ldap->keyvals ) != ldap_count_values ( ldap->valvals ) ) {
              for ( i = 0 ; ldap->keyvals[i] != NULL && ldap->valvals[i] != NULL ; i++ ) {
                switch(bind) {
                  case LDAP_DIRECTORY:
                    if(!strcmp(ldap->key,"param")) {
                      //put together the params
                      if ( bigger_xml == NULL ) bigger_xml = switch_mprintf("<param name=\"%s\" value=\"%s\" />",ldap->keyvals[i],ldap->valvals[i]);
                      else {
                        tiny_xml = switch_mprintf("<param name=\"%s\" value=\"%s\" />",ldap->keyvals[i],ldap->valvals[i]);
                        temp_xml = strdup(bigger_xml);
                        switch_safe_free(bigger_xml);
                        len = strlen(temp_xml) + strlen(tiny_xml) + 2;
                        bigger_xml = malloc(len*sizeof(char));
                        bigger_xml = memset(bigger_xml, 0, len*sizeof(char));
                        bigger_xml = strncpy(bigger_xml,temp_xml,strlen(bigger_xml) - 1);
                        bigger_xml = strncat(bigger_xml,tiny_xml,strlen(bigger_xml) - strlen(tiny_xml) - 1 );
                        switch_safe_free(temp_xml);
                        switch_safe_free(tiny_xml);
                      }
                    } else if (!strcmp(ldap->key,"variable")) {
                      //handle variable xml bits
                      if ( bigger_xml == NULL ) bigger_xml = switch_mprintf("<variable name=\"%s\" value=\"%s\" />",ldap->keyvals[i],ldap->valvals[i]);
                      else {
                        tiny_xml = switch_mprintf("<param name=\"%s\" value=\"%s\" />",ldap->keyvals[i],ldap->valvals[i]);
                        temp_xml = strdup(bigger_xml);
                        switch_safe_free(bigger_xml);
                        len = strlen(temp_xml) + strlen(tiny_xml) + 2;
                        bigger_xml = malloc(len*sizeof(char));
                        bigger_xml = memset(bigger_xml, 0, len*sizeof(char));
                        bigger_xml = strncpy(bigger_xml,temp_xml,strlen(bigger_xml) - 1);
                        bigger_xml = strncat(bigger_xml,tiny_xml,strlen(bigger_xml) - strlen(tiny_xml) - 1 );
                        switch_safe_free(temp_xml);
                        switch_safe_free(tiny_xml);
                      }
                    }
                  /* no brace here...why oh why do I indent on case */
                }
              } /* end of vals for loop */
              switch(bind){
                case LDAP_DIRECTORY:
                  if( super_xml == NULL ) { 
                    super_xml = strdup(bigger_xml);
                    switch_safe_free(bigger_xml);
                  } else {
                    temp_xml = strdup(super_xml);
                    switch_safe_free(super_xml);
                    len = strlen(temp_xml) + strlen(bigger_xml) + 2;
                    super_xml = malloc(sizeof(char) * len );
                    super_xml = memset(super_xml,0,len*sizeof(char));
                    super_xml = strncpy(temp_xml,bigger_xml,len*sizeof(char) - 1);
                    super_xml = strncat(super_xml,bigger_xml,strlen(super_xml) - strlen(bigger_xml) -1);
                    switch_safe_free(bigger_xml);
                  }
                  break;
                }
            } else {
              //something isn't quite right here there is not a val for each key
              switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "attrib count doesn't match in %s %s",ldap->key,ldap->val);
            }
          } else {
            //no vals let's move right along
          }
        }
      }
      ldap->key = ldap_next_attribute(ldap->ld, ldap->entry, ldap->berkey );
    } while ( ldap->key != NULL && ldap->val != NULL  );
  }
  if (super_xml) { 
    xml = super_xml;
    return SWITCH_STATUS_SUCCESS;
  }
  return SWITCH_STATUS_FALSE;
}


static switch_xml_t xml_ldap_search(const char *section, const char *tag_name, const char *key_name, const char *key_value, const char *params,
								  void *user_data)
{
  xml_binding_t *binding = (xml_binding_t *) user_data;
  switch_xml_t xml_ret;
  struct ldap_c ldap_connection;
  struct ldap_c *ldap = &ldap_connection;
  //switch_uuid_t uuid;
  //char uuid_str[SWITCH_UUID_FORMATTED_LENGTH + 1];
  int auth_method = LDAP_AUTH_SIMPLE;
  int desired_version = LDAP_VERSION3;

  char *search_base = NULL;
  char *xml_str, *xml;
  int xml_str_len;
  char hostname[256] = "";
  //const char *config_template = "<configuration name=\"%s\" description=\"%s\"></configuration>";
  const char *directory_template = "<document type=\"freeswitch/xml\"><section name=\"directory\"><domain name=\"%s\">%s</domain></section></document>";
  //const char *dialplan_template = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><document type=\"freeswitch/xml\"><section name=\"dialplan\" description=\"RE Dial Plan For FreeSwitch\"><context name=\"%s\"></context></section></document>";
  //const char *notfound = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><document type=\"freeswitch/xml\"><section name=\"result\"><result status=\"not found\" /></section></document>";

	gethostname(hostname, sizeof(hostname));

	if (!binding) {
    switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "no bindings...sorry bud returning now\n");
		return NULL;
	}

	search_base = switch_mprintf("id%s=%s,tag=%s,section=%s,fshost=%s,%s",switch_str_nil(key_name),switch_str_nil(key_value),switch_str_nil(tag_name),section,hostname,binding->ldap_base);

  if ((ldap->ld = ldap_init("192.168.0.50", LDAP_PORT)) == NULL) {
    switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "returning from query because we couldn't connect\n");
    return NULL;
  }

  if (ldap_set_option(ldap->ld, LDAP_OPT_PROTOCOL_VERSION, &desired_version) != LDAP_OPT_SUCCESS) {
    switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "can't set ldap protocol options\n");
    return NULL;
  }

  if (ldap_bind_s(ldap->ld, binding->binddn, binding->bindpass, auth_method) != LDAP_SUCCESS) {
    switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "didn't bind successfully\n");
    return NULL;
  }

  if (ldap_search_s(ldap->ld, search_base, LDAP_SCOPE_SUBTREE, "(objectClass=*)", NULL, 0, &ldap->msg) != LDAP_SUCCESS) {
    switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "search was not conclusive\n");
    return NULL;
  }

  if (ldap_count_entries(ldap->ld, ldap->msg) <= 0) {
    switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "search returned...just not any results\n");
    return NULL;
  }

  if ( xml_ldap_result( &ldap_connection, xml, 1) != SWITCH_STATUS_SUCCESS ){
      switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "well aint that a bitch\n");
      return NULL;
  }

  if (!xml) {
    switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "I wish I had some XML\n");
    return NULL;
  } else {
    xml_str = switch_mprintf(directory_template,hostname,xml);
    xml_str_len = strlen(xml_str);
    switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "RETURN: %s\n",xml_str);
    xml_ret = switch_xml_parse_str(xml_str,xml_str_len);
  }

  switch_safe_free(search_base);
  return xml_ret;
}


static switch_status_t do_config(void)
{
	char *cf = "xml_ldap.conf";
	switch_xml_t cfg, xml, bindings_tag, binding_tag, param;
	xml_binding_t *binding = NULL;
	int x = 0;

	if (!(xml = switch_xml_open_cfg(cf, &cfg, NULL))) {
		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "open of %s failed\n", cf);
		return SWITCH_STATUS_TERM;
	}

	if (!(bindings_tag = switch_xml_child(cfg, "bindings"))) {
		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Missing <bindings> tag!\n");
		goto done;
	}

	for (binding_tag = switch_xml_child(bindings_tag, "binding"); binding_tag; binding_tag = binding_tag->next) {
		char *bname = (char *) switch_xml_attr_soft(binding_tag, "name");
    char *ldap_base; 
    char *binddn;
    char *bindpass;
    char *bind_mask;


		for (param = switch_xml_child(binding_tag, "param"); param; param = param->next) {
			char *var = (char *) switch_xml_attr_soft(param, "name");
			char *val = (char *) switch_xml_attr_soft(param, "value");
			if (!strcasecmp(var, "base")) {
        bind_mask = (char *) switch_xml_attr_soft(param, "bindings");
        if(val) ldap_base = val;
			} else if (!strcasecmp(var, "binddn")) {
				binddn = val;
			} else if (!strcasecmp(var, "bindpass")) {
        bindpass = val;
			}
		}

		if (!ldap_base || !binddn || !bindpass ) {
			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "You must define base binddn bindpass\n");
			continue;
		}

		if (!(binding = malloc(sizeof(*binding)))) {
			goto done;
		}
		memset(binding, 0, sizeof(*binding));

    if(bind_mask)  binding->bindings = strdup(bind_mask);


		binding->ldap_base = strdup(ldap_base);
    binding->binddn = strdup(binddn);
    binding->bindpass = strdup(bindpass);


		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_NOTICE, "Binding [%s] XML Fetch Function [%s] [%s]\n",
        switch_strlen_zero(bname) ? "N/A" : bname, binding->ldap_base, binding->bindings ? binding->bindings : "all");
		switch_xml_bind_search_function(xml_ldap_search, switch_xml_parse_section_string(bname), binding);
		x++;
		binding = NULL;
	}

 done:
	switch_xml_free(xml);

  switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "returned from do_config() with status %d\n", SWITCH_STATUS_SUCCESS);
	return SWITCH_STATUS_SUCCESS;
}


SWITCH_MODULE_LOAD_FUNCTION(mod_xml_ldap_load)
{
	switch_api_interface_t *xml_ldap_api_interface;

	/* connect my internal structure to the blank pointer passed to me */
	*module_interface = switch_loadable_module_create_module_interface(pool, modname);

	SWITCH_ADD_API(xml_ldap_api_interface, "xml_ldap", "XML LDAP", xml_ldap_function, XML_LDAP_SYNTAX);
  switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "XML LDAP module loading...\n");

	if (! (do_config() == SWITCH_STATUS_SUCCESS) ) return SWITCH_STATUS_FALSE;

	/* indicate that the module should continue to be loaded */
	return SWITCH_STATUS_SUCCESS;
}

SWITCH_MODULE_SHUTDOWN_FUNCTION(mod_xml_ldap_shutdown)
{
	return SWITCH_STATUS_SUCCESS;
}

/* For Emacs:
 * Local Variables:
 * mode:c
 * indent-tabs-mode:t
 * tab-width:4
 * c-basic-offset:4
 * End:
 * For VIM:
 * vim:set softtabstop=4 shiftwidth=4 tabstop=4 expandtab:
 */
